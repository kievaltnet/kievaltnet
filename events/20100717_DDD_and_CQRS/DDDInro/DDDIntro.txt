# Введение в DDD для .NET #
* Чалый Михаил (mike@chaliy.name) *

## Немного теории ##

### Что такое ДДД? ###

- Попытка сместить акценты с базы данных или интерфейса, в строну бизнес логики.
- Тренд в построении ЛОБ приложений.
- Маштабирование логики. Горищонатльное маштабирование. Потдерживаемость.

*
	Когда я планировал что раскажу на эту встречу, думал больше про технические или даж скорее практические аспекты ДДД. Но потом подумал, что соль то не в этом. Предположим я сейчас расскажу про целый набор паттернов. Это будет нудистика еще та. Эти паттерны легко почитать в интернете или книгах. Вобщем-то я решил попробовать начать с другого. С подхода. Иногда я буду скатываться в практику. Ктомуже если возинкают вопросы как что-то реализовать технически спрашивайте.

	Итак. Подход.

	Давайте сначала сформулируем что такое ДДД. Кто уже практикует в любой форме ДДД. Кто интирисовался?
	* Ктото должен сказать про обьединение данных и поведения *
	Очень часто когда говорят про ДДД подразумевают обьединение данных и поведения. Собно это не правда. Точнее не совсем правда.
	ДДД это таки Domain-driven design. Дизайн системы на основе предметной области. Как по мне все остальное вторично.
	Если рассмартивать с этой точки зрения, то даж Entropy.png это разработка на основе предметной области. Поглядите там гдето есть Накладная, а у нее даж есть строки. Угу а тут Matrix.jpg женщина в красном.
	Красиво, но непотдерживаемо. Никто кроме того дядки из Матрицы не видит в этих зеленых циферках красного.
	Вот тут я кажись уже могу сформулировать что же такое ДДД..	
	ДДД это набор принципов, техник, хз чего которые помогают маштабировать логику.
	У меня правда со словом маштабируемость ассоциируется высоконагруженные системы типа иногда отваливающегося твиттера, фейсбука или гугла...
	Но собсно это не то.
	Маштабируемость логики это такое свойство, что скока в систему логики не пихай, она всеравно останется потдерживаемой. Она остается понятной, тестируемой.
	Собно когда я для себя это сформулировал, оказалось... DDDBook.png DDDBook2.png... все придумано до меня... это кстати Библия ДДД. Ее кстати достаточно тяжко понять. По крайней мере мне ожидавшему технической серебрянной пули было достаточно тяжело. А все потому что книга тож начала с ПОДХОДА...
	
	Вот и пришло время поговорить что же конкретно для этого предлагает ДДД.

### Основные принципы ###

- Язык понятный и бизнесу и программисту.

Собно тут все просто.

- Преславутое обьеденение данных и поведения. 

Это часто выносят во главу угла. Но реально это просто прагматичный подход. Представьте данные отдельно а логику отдельно. Фактически это обозначает что 

- Контексты.

- Незавиимость от БД.

Хексагональные арихтектуры, тестирование.

*

### Анлоги или конкуренты. ###

- Анемичные модели
- АктивРекорд

## Пример ##

Карзина в электронном магазине.

## Практика ##

### Проблема Персистанс Игноранса ###

- Это наверное самая извесная и самая глубоко обсасываемая тема.  За счет того что в ДДД базаданных вторична (один из адаптеров в терминах ортогональной архитектруры) появляються несколько несвойственных традиционным подходам проблем. Например нема идентификатора. Отсутвет возможность сделать селект (вы ограничены возможностями языка програмирования).

- Запуск приложения без БД.

#### Проблема ПОКО ####

- Чтонить про ПОКО
- Незабыть сказать что в ПОКО. К обозначает СЛР, а не С#.

#### Проблема идентификации сущностей ####

- Это даж не пролема. В ДДД сущности должны быть ПОКО. А это обозначает что никаких идентификаторов из базы данных. Отсутвие идентификаторов обьясняеться просто. В ДДД моделируються реальные сущности. А у реальных сущностей всегда есть уникалный натйральный идентификатор. У Накладных - номер, у Контрагентов - ИНН, у домов - адрес. Если идентификатора не сущетвует, то это не сущность. Это может быть ВальюОбьектом или ДоменнымЕвентом(Еванс).
- Правила хорошего тона в ДДД подразумевают полное отсутвие идентификатора базы данных. Идентификатор роявляеться не раньше чем в инраструктуре. Освременные ОРМ позволяют это реализовать (это небольшое передергивание, так как я знаю то НХибирнейт который умеет это делать).
- Надо не забыть добавить что иногда это правило можно попрать. Например мы сначала следовали этому правилу, так клиенту передавался только натуральный идентификатор. А потом надоело. И у клиента главным идентификатором стал идентификатор базы данных (незабыть расказать нафика).

### Проблема валидации ###

- Под валидацией, я подразумеваю такие вещи как Имя Контрагента не должно быть больше 56 символов и там не должно быть буквы "Ъ".
- Собсно такая валидация вообще не ответвенность модели. Для модели важно что это строка. И все.
- Прямая ответсвенность за валидацию лежит на интерфейсе (будь то юзерский графический интрфейс или веб сервис). Расказать про наш путь с валидаторами в АСП.НЕТ(а так как у нас этого еще нема, то как минимум попробовать).
- В большенстве ситуаций длину в 56 символов также фикисируют и в базе данных, реально смысла это не имеет. Просто разрешите 450 символов.

### ЮнитОфВорк, нафига и где?

- Довольно редко в опреации учавствует одина строка. Обычно их много. И по попнятным причинам хотелось бы что бы операция была атомарна. Класичесоке решение это транзакция.
- После того как сказал слово транзакция, задумался нафика вообще тогда нужен этот ЮнитОфВорк.... *почитать!*

### Развесистые обьекты, большие модели ###

- В жизни очень легко строить большие иерархии, например у организации есть подразделения, у подразделений группы, у групп люди, у людей компы и так далее. Ессно возникает желание отобразить это все в обьектной модели. Все бы ничего если бы модель не была слишком развесистой.
- Технически существуют средства для решения этой проблемы, например лейзи лоад.
- Лейзи лоад - это когда у класа Организация есть коллекция Подразделений. Подразделения загружаються только в момент обращения к подразделениям.  Как и с другой технологией скрывающей реальность с это связано несколько проблем.
- Проблема Селект Н+1 (обьяснить что это за фигня) и проблема подгрузки васего домена в память (например с сериализацией и сумму всех накладных для контрагента).
- несколько поддеревьев
- типа введения каких-то weak references и прочего

### Проблема репортинга ###

- Очень часто модель не соответствует тому что хотечеться показать. Например хочеться показать агрегированные данные из разных контекстов. Или надо посчитать что-то информационное (типа у нас 300 контрагентов и 3489 накладных).
- Одно из решений это применение принципа CQS(Command Query Separation) на уровне дизайна. В упрощенном виде это разнесение выборки (Query) и изменения (Command) по разным полностью независимым копонентам.
- Мы например используем НХиб для изменения модели, а АДО.НЕТ Дата Сервисес, для показа.

### Проблема меж контекстового общения ###

- Например контекст Продаж, в нем есть Накладная, есть контекст CRM с Контрагентами. Как реализовать сценарий когда после 100 Накладных, Контрагент становиться Спамером?
- Один из способов это Доменные Сервисы. Это класс Модели, который представляет собой одну операцию. Факт того что Контрагент становиться Спамером можно установить например при создании Накладной. Соотвевенно появляеться операция СоздатьНакладную, в котором и происходит весь меджик.
- Выглядит знакомо? Очень похоже на слой бизнес логики в стандатной трех слойной архитектуре. На самом же деле это не совсем так. Это проще всего показать в коде.
	- Операция происходит на уже созданных обьектах.
	- Операция не сохраняет обьекты, в хранилище. Это позволяет писать очень лакончиный тестовый код.
- Проблема Доменных Сервисов, *выковырять из блога*
-- Доменные сервисы размазываюь логику, так например есть ОрдерСервис и сам Ордер. Тоесть уже как минимум два места работы с Ордером. Это усложняет использование домена.
-- Доменные сервисы болеют теми же проблемами что менеджеры. Тоесть у вас есть сервис, у него есть зависимости, эти зависимости со временем имеют свойство, разрастаться. Типа ботлнек.
-- Тестируемость. В отличии от домена, эти сервисы тестируються относительно сложно. ПРиходиться делать моки и тому подобное.
- Подход который мне нравиться болше это Доменные Евенты. *Расказать про евенты*.
-- 

### Проблема левых зависимостей ###

- Представте себе ситуацию. Когда Контрагент становиться Спамером, мы доджны его ответно заспамить. Проблема в том что нам надо тестировать Контрагента. А это обозначает что Контрагента надо как-то изолировать от отсылки спама.
- Одно из решений это ДепенденсиНнжекшен. Так в Доменный обьетк инжектиться ОтылаторСпама. И как будтобы все в шиколаде. На самом же деле проблемы тока начинаються. Самая глупая это то что наш домен теперь завист от ИоК контейнера. Тоесть вы не можете больше юзать конструкторы. Другая проблема это ненжуное усложнение доменного обьекта. Ну и третяя это нарушение SRP.
- Большенство проблем может решить Доменные Евенты. Обьекту не надо знать про ИоК. Ему просто надо зафаирить евент. Обработка события теперь происходит в специальном классе, таким макаром решаеться проблема усложнения и SRP. 

### Куча конфигурации ОРМ ###

- Проблема заключаеться в том что кроме доменной моедли приходится потдерживать еще и мапинги этих обьектов в базу данных. Со временем, это начинает надоедать. Решение это использование конвеншенов.
- Первое это тулзы на подобие FluentNHibernate
- Свои генераторы. Например Т4.

### Какие ОРМ можно юзать ###

- Любые, но проблема в том сока вы потратитет время на потдержку.
- ЕнтитиФремворк - пока что судить сложно, но она уже не потдердживает ряд ключевых моментов. Например отсутвует возможность работать без идентификатора. Отсутвует возможность спрятать системные свойства(Аудит, Конкурентность).
- НХибирнейт, имеет решения для большенмтва проблем.

### Производительность ###

- В ДДД на производилеьность отрицательно влияет несколько фишек.
- Обьект загружаеться полностью, все поля, иногда даже с детишками. Понятно что тяжеловесного говна там может быть просто нереально много.
- Когда надо присвоить Счету, Контрагента. То приходиться подымать и Контрагента.
- Игонрировать производительность неззя. Пока что.
- Так например если ожидаеться большое количество данных, например картинка, то возможно ее надо сделть отдельной сущностью, и подгружать лейзи.
- Во всю использовать CQS, наша статистика это большая часть работы это таки просмотр.
- Реально оценивать проблемвы с производительностью (например в датацентрик перед присвением Контрагента Счету всеравно надо проверить идентификатор, тоесть все равно есть запрос).

### Кеширование и фармы ###

- Наверное самым удобным для програмиста бы было если бы вся модель была бы в памяти, в одном процесе. В реальности это не так.
- Мы пока что стратегически не используем кеш.
- Непродуманый обьектный кеш не работает на фарме. А например разделение по тенантам, да. Или разделение по сервисам.
- Другое решение это все тот же CQS, кешить результаты репортов вполне может себе хорошим решением.
- Кешить результаты.

### Общение между слоями ###

- AutoMapper

### DDDD ###

### Ссылки ###

http://dddsample.sourceforge.net/ - Пример на java
http://www.domaindrivendesign.org/ - Просто так
http://tech.groups.yahoo.com/group/domaindrivendesign/ - дискусионная группа
http://github.com/MarkNijhof/Fohjin - Пример DDDD на .NET

### Книги ###

Domain-Driven Design: Tackling Complexity in the Heart of Software, Eric Evans
Domain Driven Design Quickly, Eric Evans
Applying Domain-Driven Design and Patterns: With Examples in C# and .NET, Jimmy Nilsson 


[1]: http://weblogs.asp.net/arturtrosin/archive/2009/02/09/domain-driven-design-learning.aspx
[2]: http://code.google.com/p/ndddsample/
